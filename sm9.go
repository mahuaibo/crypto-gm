package gm

import (
	"crypto/rand"
	"encoding/asn1"
	"errors"
	"github.com/ultramesh/crypto-gm/internal/sm9"
)

//SM9 a tool to sign and verify. You can get SM9 instance from NewSM9(...)
type SM9 struct {
}

//Sign generate signature
func (sm9 *SM9) Sign(k []byte, msg []byte) (signature []byte, err error) {
	sk := new(SM9Key).FromBytes(k, nil)
	return sk.Sign(nil, msg)
}

//Verify verify signature
func (sm9 *SM9) Verify(k []byte, signature, msg []byte) (valid bool, err error) {
	id := new(ID).FromBytes(k, nil)
	return id.Verify(nil, signature, msg)
}

//KGCPrivKey represent KGC private key,this key should only keep by KGC.
type KGCPrivKey struct {
	KGCPubKey
	K []byte
}

//KGCPubKey represent KGC public key, it's should public.
type KGCPubKey struct {
	Pub []byte
}

//GenerateKGC generate KGC key, KGC is Key Generate Center, KGC' key also named master key.
func GenerateKGC() *KGCPrivKey {
	ks, pub := sm9.GenMasterKeyPair(rand.Reader)
	return &KGCPrivKey{K: ks, KGCPubKey: KGCPubKey{Pub: pub}}
}

//SM9Key the key generated by KGC, equivalent to the user's private key.
// User' public key is his ID.
type SM9Key struct {
	ID
	K []byte
}

//ID User's ID, equivalent to the user's public key.
type ID struct {
	ID        []byte
	KGCPubKey []byte
}

//GenerateKey generate key
func (kgc *KGCPrivKey) GenerateKey(id []byte) *SM9Key {
	k := sm9.GenSignKey(id, kgc.K)
	tmp := make([]byte, len(kgc.Pub))
	copy(tmp, kgc.Pub)
	return &SM9Key{K: k, ID: ID{ID: id, KGCPubKey: kgc.Pub}}
}

//Bytes get bytes from SM9key
func (sm9key *SM9Key) Bytes() ([]byte, error) {
	if sm9key == nil || len(sm9key.ID.ID) == 0 || len(sm9key.ID.KGCPubKey) == 0 {
		return nil, errors.New("some filed in SM9Key may be empty or nil")
	}
	return asn1.Marshal(*sm9key)
}

//FromBytes parse
func (sm9key *SM9Key) FromBytes(k []byte, _ interface{}) *SM9Key {
	_, err := asn1.Unmarshal(k, sm9key)
	if err != nil {
		return nil
	}
	return sm9key
}

//Symmetric always return false
func (sm9key *SM9Key) Symmetric() bool {
	return false
}

//Private always return true
func (sm9key *SM9Key) Private() bool {
	return true
}

//PublicKey get ID
func (sm9key *SM9Key) PublicKey() (*ID, error) {
	return &sm9key.ID, nil
}

//Sign generate signature
func (sm9key *SM9Key) Sign(_ []byte, msg []byte) (signature []byte, err error) {
	return sm9.Sign(msg, sm9key.K, sm9key.ID.KGCPubKey)
}

//Verify verify signature
func (id *ID) Verify(_ []byte, signature, msg []byte) (valid bool, err error) {
	b := sm9.Verify(string(id.ID), signature, msg, id.KGCPubKey)
	if !b {
		return false, errors.New("verify failed")
	}
	return true, nil
}

//Bytes get bytes from ID
func (id *ID) Bytes() ([]byte, error) {
	return asn1.Marshal(*id)
}

//FromBytes parse
func (id *ID) FromBytes(k []byte, _ interface{}) *ID {
	_, err := asn1.Unmarshal(k, id)
	if err != nil {
		return nil
	}
	return id
}

//Symmetric always return false
func (id *ID) Symmetric() bool {
	return false
}

//Private always return false
func (id *ID) Private() bool {
	return false
}

//PublicKey return self
func (id *ID) PublicKey() (*ID, error) {
	return id, nil
}
